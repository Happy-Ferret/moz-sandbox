<script>
/// UI

"use strict";

const USE_WORKERS = true;

function filePicked(files) {
    var reader = new FileReader();
    reader.onload = function (e) { processPGM(new Uint8Array(e.target.result)); };
    reader.readAsArrayBuffer(files[0]);
}

/// Processing

function processPGM(bytes) {
    if (USE_WORKERS) 
	processPGMOnWorkers(bytes);
    else
	processPGMOnMaster(bytes);
}

var workers = [];

function processPGMOnWorkers(bytes) {
    var { loc, width, height, maxval } = readPgm(bytes);
    var htiles = 10;
    var wtiles = 10;
    var numPieces = htiles*wtiles;
    var outBytes = copyAndZeroPgm(bytes, loc);

    function gatherPiece(event) {
	var [h, w, tile] = data;
	copyTileToResult(outBytes, loc, tile, h, w, height, width);
	if (--numPieces == 0)
	    displayPGM(outBytes);
    }

    for ( var i=0 ; i < NUM_WORKERS ; i++ ) {
	var w = new Worker("convolve-slave.js");
	w.onmessage = gatherPiece;
	workers.push();
    }

    for ( var h=0 ; h < htiles ; h++ )
	for ( var w=0 ; w < wtiles ; w++ ) {
	}
}

// Master code

function processPGMOnMaster(bytes) {
    var { loc, width, height, maxval } = readPgm(bytes);
    var outBytes = copyAndZeroPgm(bytes, loc);
    edgeDetect1(bytes, outBytes, loc, height, width);
    displayPGM(outBytes);
}

function edgeDetect1(input, output, loc, height, width) {
    function c1(xmm,xzm,xpm,xmz,xzz,xpz,xmp,xzp,xpp) {
	// (-1  0  1)
	// (-1  0  1)
	// (-1  0  1)
	return -xmm + -xzm + -xpm + xmp + xzp + xpp;
    }
    function c2(xmm,xzm,xpm,xmz,xzz,xpz,xmp,xzp,xpp) {
	// ( 1  1  1)
	// ( 0  0  0)
	// (-1 -1 -1)
	return xmm + xmz + xmp + -xpm + -xpz + -xpp;
    }
    function c3(xmm,xzm,xpm,xmz,xzz,xpz,xmp,xzp,xpp) {
	// (-1 -1 -1)
	// (-1  8 -1)
	// (-1 -1 -1)
	return -xmm + -xzm + -xpm + -xmz + 8*xzz + -xpz + -xmp + -xzp + -xpp;
    }
    function c4(xmm,xzm,xpm,xmz,xzz,xpz,xmp,xzp,xpp) {
	// ( 0  1  0)
	// (-1  0  1)
	// ( 0 -1  0)
	return xmz + -xzm + xzp + -xpz;
    }
    // A hand-written Math.max() is necessary for the parallel versions,
    // but in this serial code the in-lined version cuts the benchmark's
    // running time in half.  (Compare this to cat-convolve-map-outer.js,
    // where Math.max() is faster than the hand-written version.)
    function max2(a,b) { return a > b ? a : b }
    function max4(a,b,c,d) { return max2(max2(a,b),max2(c,d)); }
    function max5(a,b,c,d,e) { return max2(max4(a,b,c,d),e); }
    for ( var h=1 ; h < height-1 ; h++ ) {
	for ( var w=1 ; w < width-1 ; w++ ) {
	    var xmm=input[loc+(h-1)*width+(w-1)];
	    var xzm=input[loc+h*width+(w-1)];
	    var xpm=input[loc+(h+1)*width+(w-1)];
	    var xmz=input[loc+(h-1)*width+w];
	    var xzz=input[loc+h*width+w];
	    var xpz=input[loc+(h+1)*width+w];
	    var xmp=input[loc+(h-1)*width+(w+1)];
	    var xzp=input[loc+h*width+(w+1)];
	    var xpp=input[loc+(h+1)*width+(w+1)];
	    var sum=max5(0,
			 c1(xmm,xzm,xpm,xmz,xzz,xpz,xmp,xzp,xpp),
			 c2(xmm,xzm,xpm,xmz,xzz,xpz,xmp,xzp,xpp),
			 c3(xmm,xzm,xpm,xmz,xzz,xpz,xmp,xzp,xpp),
			 c4(xmm,xzm,xpm,xmz,xzz,xpz,xmp,xzp,xpp));
	    output[loc+h*width+w] = sum;
	}
    }
    return output;
}

function copyAndZeroPgm(bytes, loc) {
    var out = new Uint8Array(bytes.length);
    for ( var i=0 ; i < loc ; i++ )
	out[i] = bytes[i];
    return out;
}

/// Displaying

function displayPGM(bytes) {
    var { loc, width, height, maxval } = readPgm(bytes);
    var c = document.getElementById("mycanvas");
    var ctx = c.getContext('2d');
    c.width = width;
    c.height = height;
    for ( var h=0 ; h < height ; h++ )
        for ( var w=0 ; w < width ; w++ ) {
            var v = bytes[loc + h*width + w];
            ctx.fillStyle = "rgb(" + v + "," + v + "," + v + ")";
            ctx.fillRect(w, h, w+1, h+1);
        }
}

/// Parsing

function readPgm(bytes) {
    var loc = 0;
    var { loc, word } = getAscii(bytes, loc, true);
    if (word != "P5")
	throw "Bad magic: " + word;
    var { loc, word } = getAscii(bytes, loc);
    var width = parseInt(word);
    var { loc, word } = getAscii(bytes, loc);
    var height = parseInt(word);
    var { loc, word } = getAscii(bytes, loc);
    var maxval = parseInt(word);
    loc++;
    return { loc: loc, width: width, height: height, maxval: maxval };
}

function getAscii(bytes, loc, here) {
    if (!here)
	loc = skipWhite(bytes, loc);
    var s = "";
    while (loc < bytes.length && bytes[loc] > 32)
	s += String.fromCharCode(bytes[loc++]);
    return { loc: loc, word: s };
}

function skipWhite(bytes, loc) {
    while (loc < bytes.length && bytes[loc] <= 32)
	loc++;
    return loc;
}
</script>

<input type="file" id="mypicker" onchange="filePicked(this.files)">
<canvas id="mycanvas" width=10 height=10>

