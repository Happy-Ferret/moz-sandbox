# HG changeset patch
# User Lars T Hansen <lhansen@mozilla.com>
# Date 1455647528 -3600
#      Tue Feb 16 19:32:08 2016 +0100
# Node ID eee70b7a8c148ab22952429daa3c2d1fc217206c
# Parent  891c83f794121721ca124053e7ea83423b11282a
Bug 1248670 - 'synchronic' methods on Atomics

diff --git a/js/src/builtin/AtomicsObject.cpp b/js/src/builtin/AtomicsObject.cpp
--- a/js/src/builtin/AtomicsObject.cpp
+++ b/js/src/builtin/AtomicsObject.cpp
@@ -710,28 +710,32 @@ namespace js {
 // the 'lower_pri' field.  The 'back' field goes the other direction.
 // The list is circular, so the 'lower_pri' field of the lowest priority
 // node points to the first node in the list.  The list has no dedicated
 // header node.
 
 class FutexWaiter
 {
   public:
-    FutexWaiter(uint32_t offset, JSRuntime* rt)
+    enum Kind { KIND_FUTEX, KIND_SYNCHRONIC };
+
+    FutexWaiter(uint32_t offset, JSRuntime* rt, Kind kind)
       : offset(offset),
         rt(rt),
         lower_pri(nullptr),
-        back(nullptr)
+        back(nullptr),
+        kind(kind)
     {
     }
 
     uint32_t    offset;                 // int32 element index within the SharedArrayBuffer
     JSRuntime*  rt;                    // The runtime of the waiter
     FutexWaiter* lower_pri;             // Lower priority nodes in circular doubly-linked list of waiters
     FutexWaiter* back;                  // Other direction
+    Kind kind;
 };
 
 class AutoLockFutexAPI
 {
   public:
     AutoLockFutexAPI() {
         FutexRuntime::lock();
     }
@@ -799,17 +803,17 @@ js::atomics_futexWait(JSContext* cx, uns
     if (jit::AtomicOperations::loadSafeWhenRacy(addr) != value) {
         r.setInt32(AtomicsObject::FutexNotequal);
         return true;
     }
 
     Rooted<SharedArrayBufferObject*> sab(cx, view->bufferShared());
     SharedArrayRawBuffer* sarb = sab->rawBufferObject();
 
-    FutexWaiter w(offset, rt);
+    FutexWaiter w(offset, rt, FutexWaiter::KIND_FUTEX);
     if (FutexWaiter* waiters = sarb->waiters()) {
         w.lower_pri = waiters;
         w.back = waiters->back;
         waiters->back->lower_pri = &w;
         waiters->back = &w;
     } else {
         w.lower_pri = w.back = &w;
         sarb->setWaiters(&w);
@@ -861,17 +865,17 @@ js::atomics_futexWake(JSContext* cx, uns
     int32_t woken = 0;
 
     FutexWaiter* waiters = sarb->waiters();
     if (waiters && count > 0) {
         FutexWaiter* iter = waiters;
         do {
             FutexWaiter* c = iter;
             iter = iter->lower_pri;
-            if (c->offset != offset || !c->rt->fx.isWaiting())
+            if (c->kind != FutexWaiter::KIND_FUTEX || c->offset != offset || !c->rt->fx.isWaiting())
                 continue;
             c->rt->fx.wake(FutexRuntime::WakeExplicit);
             ++woken;
             --count;
         } while (count > 0 && iter != waiters);
     }
 
     r.setInt32(woken);
@@ -929,32 +933,32 @@ js::atomics_futexWakeOrRequeue(JSContext
 
     FutexWaiter* waiters = sarb->waiters();
     if (!waiters) {
         r.setInt32(0);
         return true;
     }
 
     int32_t woken = 0;
-    FutexWaiter whead((uint32_t)-1, nullptr); // Header node for waiters
+    FutexWaiter whead((uint32_t)-1, nullptr, FutexWaiter::KIND_FUTEX); // Header node for waiters
     FutexWaiter* first = waiters;
     FutexWaiter* last = waiters->back;
     whead.lower_pri = first;
     whead.back = last;
     first->back = &whead;
     last->lower_pri = &whead;
 
-    FutexWaiter rhead((uint32_t)-1, nullptr); // Header node for requeued
+    FutexWaiter rhead((uint32_t)-1, nullptr, FutexWaiter::KIND_FUTEX); // Header node for requeued
     rhead.lower_pri = rhead.back = &rhead;
 
     FutexWaiter* iter = whead.lower_pri;
     while (iter != &whead) {
         FutexWaiter* c = iter;
         iter = iter->lower_pri;
-        if (c->offset != offset1 || !c->rt->fx.isWaiting())
+        if (c->kind != FutexWaiter::KIND_FUTEX || c->offset != offset1 || !c->rt->fx.isWaiting())
             continue;
         if (count > 0) {
             c->rt->fx.wake(FutexRuntime::WakeExplicit);
             ++woken;
             --count;
         } else {
             c->offset = offset2;
 
@@ -1209,31 +1213,240 @@ js::FutexRuntime::wake(WakeReason reason
         state_ = WaitingNotifiedForInterrupt;
         break;
       default:
         MOZ_CRASH();
     }
     PR_NotifyCondVar(cond_);
 }
 
+// FIXME: futexWait can use this machinery, with minor adjustments
+
+enum class Condition
+{
+    NOT_EQUAL,
+    EQUAL
+};
+
+static bool
+WaitForCondition(JSContext* cx, Handle<TypedArrayObject*> view, uint32_t offset, int32_t& value, Condition cond, double timeout_ms)
+{
+    JSRuntime* rt = cx->runtime();
+
+    if (!rt->fx.canWait())
+        return ReportCannotWait(cx);
+
+    // This lock also protects the "waiters" field on SharedArrayRawBuffer,
+    // and it provides the necessary memory fence.
+    AutoLockFutexAPI lock;
+
+    bool retval = true;
+
+    SharedMem<int32_t*>(addr) = view->viewDataShared().cast<int32_t*>() + offset;
+
+    int32_t mem_val = jit::AtomicOperations::loadSafeWhenRacy(addr); // OH RLY?
+    if ((cond == Condition::EQUAL) == (mem_val == value)) {
+        value = mem_val;
+        return true;
+    }
+
+    Rooted<SharedArrayBufferObject*> sab(cx, view->bufferShared());
+    SharedArrayRawBuffer* sarb = sab->rawBufferObject();
+
+    FutexWaiter w(offset, rt, FutexWaiter::KIND_SYNCHRONIC);
+
+    for (;;) {
+        if (FutexWaiter* waiters = sarb->waiters()) {
+            w.lower_pri = waiters;
+            w.back = waiters->back;
+            waiters->back->lower_pri = &w;
+            waiters->back = &w;
+        } else {
+            w.lower_pri = w.back = &w;
+            sarb->setWaiters(&w);
+        }
+
+        AtomicsObject::FutexWaitResult result = AtomicsObject::FutexOK;
+        retval = rt->fx.wait(cx, timeout_ms, &result);
+        if (!retval)
+            break;
+        int32_t mem_val = jit::AtomicOperations::loadSafeWhenRacy(addr); // OH RLY?
+        if ((cond == Condition::EQUAL) == (mem_val == value)) {
+            value = mem_val;
+            break;
+        }
+    }
+
+    if (w.lower_pri == &w) {
+        sarb->setWaiters(nullptr);
+    } else {
+        w.lower_pri->back = w.back;
+        w.back->lower_pri = w.lower_pri;
+        if (sarb->waiters() == &w)
+            sarb->setWaiters(w.lower_pri);
+    }
+
+    return retval;
+}
+
+bool
+js::atomics_expectUpdate(JSContext* cx, unsigned argc, Value* vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+    HandleValue objv = args.get(0);
+    HandleValue idxv = args.get(1);
+    HandleValue valv = args.get(2);
+    HandleValue timeoutv = args.get(3);
+    MutableHandleValue r = args.rval();
+
+    Rooted<TypedArrayObject*> view(cx, nullptr);
+    if (!GetSharedTypedArray(cx, objv, &view))
+        return false;
+    if (view->type() != Scalar::Int32)
+        return ReportBadArrayType(cx);
+    uint32_t offset;
+    if (!GetTypedArrayIndex(cx, idxv, view, &offset))
+        return false;
+    int32_t value;
+    if (!ToInt32(cx, valv, &value))
+        return false;
+    double timeout_ms;
+    if (timeoutv.isUndefined()) {
+        timeout_ms = mozilla::PositiveInfinity<double>();
+    } else {
+        if (!ToNumber(cx, timeoutv, &timeout_ms))
+            return false;
+        if (mozilla::IsNaN(timeout_ms))
+            timeout_ms = mozilla::PositiveInfinity<double>();
+        else if (timeout_ms < 0)
+            timeout_ms = 0;
+    }
+
+    r.setUndefined();
+
+    return WaitForCondition(cx, view, offset, value, Condition::NOT_EQUAL, timeout_ms);
+}
+
+bool
+js::atomics_waitUntilEqual(JSContext* cx, unsigned argc, Value* vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+    HandleValue objv = args.get(0);
+    HandleValue idxv = args.get(1);
+    HandleValue valv = args.get(2);
+    MutableHandleValue r = args.rval();
+
+    Rooted<TypedArrayObject*> view(cx, nullptr);
+    if (!GetSharedTypedArray(cx, objv, &view))
+        return false;
+    if (view->type() != Scalar::Int32)
+        return ReportBadArrayType(cx);
+    uint32_t offset;
+    if (!GetTypedArrayIndex(cx, idxv, view, &offset))
+        return false;
+    int32_t value;
+    if (!ToInt32(cx, valv, &value))
+        return false;
+
+    if (!WaitForCondition(cx, view, offset, value, Condition::EQUAL, mozilla::PositiveInfinity<double>()))
+        return false;
+
+    r.setInt32(value);
+    return true;
+}
+
+bool
+js::atomics_waitUntilNotEqual(JSContext* cx, unsigned argc, Value* vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+    HandleValue objv = args.get(0);
+    HandleValue idxv = args.get(1);
+    HandleValue valv = args.get(2);
+    MutableHandleValue r = args.rval();
+
+    Rooted<TypedArrayObject*> view(cx, nullptr);
+    if (!GetSharedTypedArray(cx, objv, &view))
+        return false;
+    if (view->type() != Scalar::Int32)
+        return ReportBadArrayType(cx);
+    uint32_t offset;
+    if (!GetTypedArrayIndex(cx, idxv, view, &offset))
+        return false;
+    int32_t value;
+    if (!ToInt32(cx, valv, &value))
+        return false;
+
+    if (!WaitForCondition(cx, view, offset, value, Condition::NOT_EQUAL, mozilla::PositiveInfinity<double>()))
+        return false;
+
+    r.setInt32(value);
+    return true;
+}
+
+bool
+js::atomics_notify(JSContext* cx, unsigned argc, Value* vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+    HandleValue objv = args.get(0);
+    HandleValue idxv = args.get(1);
+    MutableHandleValue r = args.rval();
+
+    Rooted<TypedArrayObject*> view(cx, nullptr);
+    if (!GetSharedTypedArray(cx, objv, &view))
+        return false;
+    if (view->type() != Scalar::Int32)
+        return ReportBadArrayType(cx);
+    uint32_t offset;
+    if (!GetTypedArrayIndex(cx, idxv, view, &offset))
+        return false;
+
+    AutoLockFutexAPI lock;
+
+    Rooted<SharedArrayBufferObject*> sab(cx, view->bufferShared());
+    SharedArrayRawBuffer* sarb = sab->rawBufferObject();
+    int32_t woken = 0;
+
+    FutexWaiter* waiters = sarb->waiters();
+    int32_t count = 1;
+    if (waiters) {
+        FutexWaiter* iter = waiters;
+        do {
+            FutexWaiter* c = iter;
+            iter = iter->lower_pri;
+            if (c->kind != FutexWaiter::KIND_SYNCHRONIC || c->offset != offset || !c->rt->fx.isWaiting())
+                continue;
+            c->rt->fx.wake(FutexRuntime::WakeExplicit);
+            ++woken;
+            --count;
+        } while (count > 0 && iter != waiters);
+    }
+
+    r.setUndefined();
+    return true;
+}
+
 const JSFunctionSpec AtomicsMethods[] = {
     JS_INLINABLE_FN("compareExchange",    atomics_compareExchange,    4,0, AtomicsCompareExchange),
     JS_INLINABLE_FN("load",               atomics_load,               2,0, AtomicsLoad),
     JS_INLINABLE_FN("store",              atomics_store,              3,0, AtomicsStore),
     JS_INLINABLE_FN("exchange",           atomics_exchange,           3,0, AtomicsExchange),
     JS_INLINABLE_FN("fence",              atomics_fence,              0,0, AtomicsFence),
     JS_INLINABLE_FN("add",                atomics_add,                3,0, AtomicsAdd),
     JS_INLINABLE_FN("sub",                atomics_sub,                3,0, AtomicsSub),
     JS_INLINABLE_FN("and",                atomics_and,                3,0, AtomicsAnd),
     JS_INLINABLE_FN("or",                 atomics_or,                 3,0, AtomicsOr),
     JS_INLINABLE_FN("xor",                atomics_xor,                3,0, AtomicsXor),
     JS_INLINABLE_FN("isLockFree",         atomics_isLockFree,         1,0, AtomicsIsLockFree),
     JS_FN("futexWait",                    atomics_futexWait,          4,0),
     JS_FN("futexWake",                    atomics_futexWake,          3,0),
     JS_FN("futexWakeOrRequeue",           atomics_futexWakeOrRequeue, 5,0),
+    JS_FN("expectUpdate",                 atomics_expectUpdate,       4,0),
+    JS_FN("waitUntilEqual",               atomics_waitUntilEqual,     3,0),
+    JS_FN("waitUntilNotEqual",            atomics_waitUntilNotEqual,  4,0),
+    JS_FN("notify",                       atomics_notify,             2,0),
     JS_FS_END
 };
 
 static const JSConstDoubleSpec AtomicsConstants[] = {
     {"OK",       AtomicsObject::FutexOK},
     {"TIMEDOUT", AtomicsObject::FutexTimedout},
     {"NOTEQUAL", AtomicsObject::FutexNotequal},
     {0,          0}
diff --git a/js/src/builtin/AtomicsObject.h b/js/src/builtin/AtomicsObject.h
--- a/js/src/builtin/AtomicsObject.h
+++ b/js/src/builtin/AtomicsObject.h
@@ -38,16 +38,20 @@ bool atomics_add(JSContext* cx, unsigned
 bool atomics_sub(JSContext* cx, unsigned argc, Value* vp);
 bool atomics_and(JSContext* cx, unsigned argc, Value* vp);
 bool atomics_or(JSContext* cx, unsigned argc, Value* vp);
 bool atomics_xor(JSContext* cx, unsigned argc, Value* vp);
 bool atomics_isLockFree(JSContext* cx, unsigned argc, Value* vp);
 bool atomics_futexWait(JSContext* cx, unsigned argc, Value* vp);
 bool atomics_futexWake(JSContext* cx, unsigned argc, Value* vp);
 bool atomics_futexWakeOrRequeue(JSContext* cx, unsigned argc, Value* vp);
+bool atomics_expectUpdate(JSContext* cx, unsigned argc, Value* vp);
+bool atomics_waitUntilEqual(JSContext* cx, unsigned argc, Value* vp);
+bool atomics_waitUntilNotEqual(JSContext* cx, unsigned argc, Value* vp);
+bool atomics_notify(JSContext* cx, unsigned argc, Value* vp);
 
 /* asm.js callouts */
 int32_t atomics_add_asm_callout(int32_t vt, int32_t offset, int32_t value);
 int32_t atomics_sub_asm_callout(int32_t vt, int32_t offset, int32_t value);
 int32_t atomics_and_asm_callout(int32_t vt, int32_t offset, int32_t value);
 int32_t atomics_or_asm_callout(int32_t vt, int32_t offset, int32_t value);
 int32_t atomics_xor_asm_callout(int32_t vt, int32_t offset, int32_t value);
 int32_t atomics_cmpxchg_asm_callout(int32_t vt, int32_t offset, int32_t oldval, int32_t newval);
diff --git a/js/src/tests/shell/synchronic.js b/js/src/tests/shell/synchronic.js
new file mode 100644
--- /dev/null
+++ b/js/src/tests/shell/synchronic.js
@@ -0,0 +1,47 @@
+if (!(this.SharedArrayBuffer && this.getSharedArrayBuffer && this.setSharedArrayBuffer)) {
+    reportCompare(true,true);
+    quit(0);
+}
+
+if (helperThreadCount() === 0) {
+  // Abort if there is no helper thread.
+  reportCompare(true,true);
+  quit();
+}
+
+var DEBUG = false;
+
+function dprint(s) {
+    if (DEBUG) print(s);
+}
+
+// Tests the SharedArrayBuffer mailbox in the shell.
+// Tests the futex functionality in the shell.
+
+var sab = new SharedArrayBuffer(12);
+var mem = new Int32Array(sab);
+
+// Futex test
+
+// Main is sharing the buffer with the worker; the worker is clearing
+// the buffer.
+
+mem[0] = 0;
+setSharedArrayBuffer(mem.buffer);
+
+evalInWorker(`
+var mem = new Int32Array(getSharedArrayBuffer());
+var then = Date.now();
+Atomics.expectUpdate(mem, 0, 0);
+var now = Date.now();
+print("Time waiting: " + (now - then));
+`);
+
+print("The worker should wait approx 3s");
+sleep(1);
+Atomics.notify(mem, 0);
+sleep(1);
+Atomics.notify(mem, 0);
+sleep(1);
+Atomics.store(mem, 0, 1);
+Atomics.notify(mem, 0);
