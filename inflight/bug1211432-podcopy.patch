# HG changeset patch
# User Lars T Hansen <lhansen@mozilla.com>
# Date 1447785109 -3600
#      Tue Nov 17 19:31:49 2015 +0100
# Node ID 0615364f7b0ddff48db5e346357148e2f991d67c
# Parent  db9e19d4bbb9eb8885d02b4379ba19233b529a2e
Bug 1211432 - provide PodCopy and PodMove safe-when-racy operations

diff --git a/js/src/builtin/SIMD.cpp b/js/src/builtin/SIMD.cpp
--- a/js/src/builtin/SIMD.cpp
+++ b/js/src/builtin/SIMD.cpp
@@ -1161,17 +1161,17 @@ Load(JSContext* cx, unsigned argc, Value
         return false;
 
     Rooted<TypedObject*> result(cx, TypedObject::createZeroed(cx, typeDescr, 0));
     if (!result)
         return false;
 
     SharedMem<Elem*> src = AnyTypedArrayViewData(typedArray).addBytes(byteStart).cast<Elem*>();
     Elem* dst = reinterpret_cast<Elem*>(result->typedMem());
-    jit::AtomicOperations::memcpySafeWhenRacy(dst, src, sizeof(Elem) * NumElem);
+    jit::AtomicOperations::PodCopySafeWhenRacy(dst, src, NumElem);
 
     args.rval().setObject(*result);
     return true;
 }
 
 template<class V, unsigned NumElem>
 static bool
 Store(JSContext* cx, unsigned argc, Value* vp)
@@ -1187,17 +1187,17 @@ Store(JSContext* cx, unsigned argc, Valu
     if (!TypedArrayFromArgs<Elem, NumElem>(cx, args, &typedArray, &byteStart))
         return false;
 
     if (!IsVectorObject<V>(args[2]))
         return ErrorBadArgs(cx);
 
     Elem* src = TypedObjectMemory<Elem*>(args[2]);
     SharedMem<Elem*> dst = AnyTypedArrayViewData(typedArray).addBytes(byteStart).cast<Elem*>();
-    js::jit::AtomicOperations::memcpySafeWhenRacy(dst, src, sizeof(Elem) * NumElem);
+    js::jit::AtomicOperations::PodCopySafeWhenRacy(dst, src, NumElem);
 
     args.rval().setObject(args[2].toObject());
     return true;
 }
 
 #define DEFINE_SIMD_FLOAT32X4_FUNCTION(Name, Func, Operands)       \
 bool                                                               \
 js::simd_float32x4_##Name(JSContext* cx, unsigned argc, Value* vp) \
diff --git a/js/src/jit/AtomicOperations.h b/js/src/jit/AtomicOperations.h
--- a/js/src/jit/AtomicOperations.h
+++ b/js/src/jit/AtomicOperations.h
@@ -238,16 +238,34 @@ class AtomicOperations
     static void memcpySafeWhenRacy(T dest, SharedMem<T> src, size_t nbytes) {
         memcpySafeWhenRacy(static_cast<void*>(dest), static_cast<void*>(src.unwrap()), nbytes);
     }
 
     template<typename T>
     static void memmoveSafeWhenRacy(SharedMem<T> dest, SharedMem<T> src, size_t nbytes) {
         memmoveSafeWhenRacy(static_cast<void*>(dest.unwrap()), static_cast<void*>(src.unwrap()), nbytes);
     }
+
+    template<typename T>
+    static void PodCopySafeWhenRacy(SharedMem<T> dest, SharedMem<T> src, size_t nelem) {
+        MOZ_RELEASE_ASSERT(nelem <= SIZE_MAX / sizeof(T),
+                           "trying to copy an impossible number of elements");
+        memcpySafeWhenRacy(static_cast<void*>(dest.unwrap()),
+                           static_cast<void*>(src.unwrap()),
+                           nelem*sizeof(T));
+    }
+
+    template<typename T>
+    static void PodMoveSafeWhenRacy(SharedMem<T> dest, SharedMem<T> src, size_t nelem) {
+        MOZ_RELEASE_ASSERT(nelem <= SIZE_MAX / sizeof(T),
+                           "trying to copy an impossible number of elements");
+        memmoveSafeWhenRacy(static_cast<void*>(dest.unwrap()),
+                           static_cast<void*>(src.unwrap()),
+                           nelem*sizeof(T));
+    }
 };
 
 /* A data type representing a lock on some region of a
  * SharedArrayRawBuffer's memory, to be used only when the hardware
  * does not provide necessary atomicity (eg, float64 access on ARMv6
  * and some ARMv7 systems).
  */
 class RegionLock
diff --git a/js/src/vm/TypedArrayCommon.h b/js/src/vm/TypedArrayCommon.h
--- a/js/src/vm/TypedArrayCommon.h
+++ b/js/src/vm/TypedArrayCommon.h
@@ -158,16 +158,26 @@ class SharedOps
     static void memcpy(SharedMem<T*> dest, SharedMem<T*> src, size_t size) {
         js::jit::AtomicOperations::memcpySafeWhenRacy(dest, src, size);
     }
 
     template<typename T>
     static void memmove(SharedMem<T*> dest, SharedMem<T*> src, size_t size) {
         js::jit::AtomicOperations::memmoveSafeWhenRacy(dest, src, size);
     }
+
+    template<typename T>
+    static void PodCopy(SharedMem<T*> dest, SharedMem<T*> src, size_t nelem) {
+        js::jit::AtomicOperations::PodCopySafeWhenRacy(dest, src, nelem);
+    }
+
+    template<typename T>
+    static void PodMove(SharedMem<T*> dest, SharedMem<T*> src, size_t nelem) {
+        js::jit::AtomicOperations::PodMoveSafeWhenRacy(dest, src, nelem);
+    }
 };
 
 class UnsharedOps
 {
   public:
     template<typename T>
     static T load(SharedMem<T*> addr) {
         return *addr.unwrapUnshared();
@@ -182,16 +192,26 @@ class UnsharedOps
     static void memcpy(SharedMem<T*> dest, SharedMem<T*> src, size_t size) {
         ::memcpy(dest.unwrapUnshared(), src.unwrapUnshared(), size);
     }
 
     template<typename T>
     static void memmove(SharedMem<T*> dest, SharedMem<T*> src, size_t size) {
         ::memmove(dest.unwrapUnshared(), src.unwrapUnshared(), size);
     }
+
+    template<typename T>
+    static void PodCopy(SharedMem<T*> dest, SharedMem<T*> src, size_t nelem) {
+        mozilla::PodCopy(dest, src, nelem);
+    }
+
+    template<typename T>
+    static void PodMove(SharedMem<T*> dest, SharedMem<T*> src, size_t nelem) {
+        mozilla::PodMove(dest, src, nelem);
+    }
 };
 
 template<class SpecificArray, typename Ops>
 class ElementSpecific
 {
     typedef typename SpecificArray::ElementType T;
     typedef typename SpecificArray::SomeTypedArray SomeTypedArray;
 
@@ -217,17 +237,17 @@ class ElementSpecific
             if (SomeTypedArray::sameBuffer(target, src))
                 return setFromOverlappingTypedArray(cx, target, src, offset);
         }
 
         SharedMem<T*> dest = AnyTypedArrayViewData(target).template cast<T*>() + offset;
         uint32_t count = AnyTypedArrayLength(source);
 
         if (AnyTypedArrayType(source) == target->type()) {
-            Ops::memcpy(dest.template cast<void*>(), AnyTypedArrayViewData(source), count*sizeof(T));
+            Ops::PodCopy(dest.template cast<void*>(), AnyTypedArrayViewData(source), count);
             return true;
         }
 
         // Inhibit unaligned accesses on ARM (bug 1097253, a compiler bug).
 #ifdef __arm__
 #  define JS_VOLATILE_ARM volatile
 #else
 #  define JS_VOLATILE_ARM
@@ -364,17 +384,17 @@ class ElementSpecific
 
         MOZ_ASSERT(offset <= target->length());
         MOZ_ASSERT(source->length() <= target->length() - offset);
 
         SharedMem<T*> dest = AnyTypedArrayViewData(target).template cast<T*>() + offset;
         uint32_t len = source->length();
 
         if (source->type() == target->type()) {
-            Ops::memmove(dest, AnyTypedArrayViewData(source).template cast<T*>(), len*sizeof(T));
+            Ops::PodMove(dest, AnyTypedArrayViewData(source).template cast<T*>(), len);
             return true;
         }
 
         // Copy |source| in case it overlaps the target elements being set.
         size_t sourceByteLen = len * source->bytesPerElement();
         void* data = target->zone()->template pod_malloc<uint8_t>(sourceByteLen);
         if (!data)
             return false;
